Linux
Filesystem
====
The common terminology for mounting a filesystem is “mount a device on a mount point.” To learn the current filesystem status of your system, you run mount. The output (which can be quite lengthy) should look like this:

$ mount
/dev/sda1 on / type ext4 (rw,errors=remount-ro)
proc on /proc type proc (rw,noexec,nosuid,nodev)
sysfs on /sys type sysfs (rw,noexec,nosuid,nodev)
fusectl on /sys/fs/fuse/connections type fusectl (rw)
debugfs on /sys/kernel/debug type debugfs (rw)
securityfs on /sys/kernel/security type securityfs (rw)
udev on /dev type devtmpfs (rw,mode=0755)
devpts on /dev/pts type devpts (rw,noexec,nosuid,gid=5,mode=0620)
tmpfs on /run type tmpfs (rw,noexec,nosuid,size=10%,mode=0755)
--snip--
Each line corresponds to one currently mounted filesystem, with items in this order:

The device, such as /dev/sda3. Notice that some of these aren’t real devices (proc, for example) but are stand-ins for real device names because these special-purpose filesystems do not need devices.
The word on.
The mount point.
The word type.
The filesystem type, usually in the form of a short identifier.
Mount options (in parentheses). See Section 4.2.6 for more details.
To mount a filesystem manually, use the mount command as follows with the filesystem type, device, and desired mount point:

# mount -t type device mountpoint
For example, to mount the Fourth Extended filesystem found on the device /dev/sdf2 on /home/extra, use this command:

# mount -t ext4 /dev/sdf2 /home/extra
You normally don’t need to supply the -t type option because mount usually figures it out for you. However, sometimes it’s necessary to distinguish between two similar types, such as the various FAT-style filesystems.

To unmount (detach) a filesystem, use the umount command as follows:

# umount mountpoint
You can also unmount a filesystem with its device instead of its mount point.


TOP Command
You can send commands to top with keystrokes. Its most frequently used commands deal with changing the sort order or filtering the process list:

Spacebar Updates the display immediately
M Sorts by current resident memory usage
T Sorts by total (cumulative) CPU usage
P Sorts by current CPU usage (the default)
u Displays only one user’s processes
f Selects different statistics to display
? Displays a usage summary for all top commands

PS command and threads
If you want to view the TIDs with ps, you can use a custom output format. Listing 8-2 shows only the PIDs, TIDs, and command:

$ ps m -o pid,tid,command
  PID   TID    COMMAND
 3587     -    bash
    -  3587    -
 3592     -    bash
    -  3592    -
 12534    -    /usr/lib/xorg/Xorg -core :0
    - 12534    -
    - 13227    -
    - 14443    -
    - 14448    -

IP Route table
$ ip route show
default via 10.23.2.1 dev enp0s31f6 proto static metric 100 
10.23.2.0/24 dev enp0s31f6 proto kernel scope link src 10.23.2.4 metric 100

The first field you encounter is 10.23.2.0/24, which is a destination network. As with previous examples, this is the host’s local subnet. This rule says that the host can reach the local subnet directly through its network interface, indicated by the dev enp0s31f6 mechanism label after the destination. 
Then we can move back to the first line of output, which has the destination network default. This rule, which matches any host at all, is also called the default route, explained in the next section. The mechanism is via 10.23.2.1, indicating that traffic using the default route is to be sent to 10.23.2.1 (in our example network, this is a router); dev enp0s31f6 indicates that the physical transmission will happen on that network interface.


The entry for default in the routing table has special significance because it matches any address on the internet. In CIDR notation, it’s 0.0.0.0/0 for IPv4. This is the default route, and the address configured as the intermediary in the default route is the default gateway. When no other rules match, the default route always does, and the default gateway is where you send messages when there is no other choice. You can configure a host without a default gateway, but it won’t be able to reach hosts outside the destinations in the routing table.

Also try $route -n

My linux showed
[ec2-user@ip-10-58-182-104 ~]$ ip route 
default via 10.58.182.97 dev eth0 
10.58.182.96/27 dev eth0 proto kernel scope link src 10.58.182.104 
169.254.169.254 dev eth0 


So what is this 169.... See https://askubuntu.com/questions/660355/why-169-254-0-0-appears-by-default-in-the-routing-table
This address is for direct ethernet communication , called local-link
[ec2-user@ip-10-58-182-104 ~]$ cat /etc/networks
default 0.0.0.0
loopback 127.0.0.0
link-local 169.254.0.0

DNS
=====
$ /etc/resolve.conf 
options timeout:2 attempts:5
; generated by /usr/sbin/dhclient-script
search us-west-2.compute.internal
nameserver 10.58.182.2

whatever incomplete hostname like foo becomes foo.us-west-2.compute.internal for lookup
$ /etc/nsswitch.conf (among other things it returns)
hosts:      files dns myhostname
This is the order of search, first would /etc/hosts file

$ netstat -nt
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address          Foreign Address         State      
tcp        0      0 10.23.2.4:47626        10.194.79.125:5222      ESTABLISHED

$ netstat -ntl
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address          Foreign Address         State          
1 tcp        0      0 0.0.0.0:80             0.0.0.0:*               LISTEN

Line 1 with 0.0.0.0:80 as the local address shows that the local machine is listening on port 80 for connections from any remote machine;

Table 9-2: Private Networks Defined by RFC 1918 and 6761

Network		Subnet mask	CIDR form
10.0.0.0	255.0.0.0	10.0.0.0/8
192.168.0.0	255.255.0.0	192.168.0.0/16
172.16.0.0	255.240.0.0	172.16.0.0/12

Understanding DHCP
Under IPv4, when you set a network host to get its configuration automatically from the network, you’re telling it to use the Dynamic Host Configuration Protocol (DHCP) to get an IP address, subnet mask, default gateway, and DNS servers. Aside from not having to enter these parameters by hand, network administrators gain other advantages with DHCP, such as preventing IP address clashes and minimizing the impact of network changes. It’s very rare to see a network that doesn’t use DHCP.

For a host to get its configuration with DHCP, it must be able to send messages to a DHCP server on its connected network. Therefore, each physical network should have its own DHCP server, and on a simple network (such as the one in Section 9.1), the router usually acts as the DHCP server.

Control Groups (cgroups)
The basic idea is that you place several processes into a cgroup, which allows you to manage the resources that they consume on a group-wide basis. For example, if you want to limit the amount of memory that a set of processes may cumulatively consume, a cgroup can do this.

After creating a cgroup, you can add processes to it, and then use a controller to change how those processes behave. For example, there is a cpu controller allowing you to limit the processor time, a memory controller, and so on.


Build Container as tar
=========================
On Amazon Linux, need to install debbootstrap first
$ wget https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm
$ sudo rpm -Uvh epel-release-latest-7.noarch.rpm 
$ sudo yum install debootstrap.noarch

Now, run debbootstrap targetting the temp directory where you want the root to be. Note that the directory must be mounted as "exec" and "dev"
$ sudo mount -o remount,exec,dev /tmp
$ sudo debootstrap stable /tmp/tmp.Zk5Gjh4ZQK/ http://deb.debian.org/debian/

Tar it up
$cd /tmp/tmp.Zk5Gjh4ZQK/
$ sudo tar zcvf ../expdockerdeb.tar ./
$ sudo chmod u+rwx expdockerdeb.tar
$ sudo chmod o+rwx expdockerdeb.tar

Make container
$ cat /tmp/expdockerdeb.tar | docker import - expdebian

Run
docker run -t -i ${container_id} /bin/bash

chroot
========
After I installed debian in a folder , I added a shell script that can run a simple hello world python script.
$ sudo chroot /tmp/tmp.UE6r8P5wL/ /home/bin/msexprun.sh
didn't work since it couldn't find python which wasn't installed in /tmp/tmp.UE6r8P5wL/ which is the new root (/)
So then i did this 
$ sudo chroot /tmp/tmp.UE6r8P5wL/ /bin/bash
which took me to the shell in new root, so if you did
$ root@ip-10-58-182-104:/# cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 12 (bookworm)"
NAME="Debian GNU/Linux"
VERSION_ID="12"
VERSION="12 (bookworm)"
VERSION_CODENAME=bookworm
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"

then install python in this new root
$ root@ip-10-58-182-104:/# apt -y upgrade
then 
$ [ec2-user@ip-10-58-182-104 ~]$ sudo chroot /tmp/tmp.UE6r8P5wL/ /home/bin/msexprun.sh
works !!

By default proc file system is not mounted, so lets say you did this -	
$ sudo chroot /tmp/tmp.UE6r8P5wL/ /bin/bash
and then tried 

root@ip-10-58-182-104:/# ps aux  
Error, do this: mount -t proc proc /proc

So proc fs has to be mounted and then within the changed root process I can see all processes on machine

root@ip-10-58-182-104:/# python3 -m http.server &>/dev/null &
[1] 4560
root@ip-10-58-182-104:/# ps aux | grep python
root      4560  0.1  0.4  24536 18280 ?        S    08:37   0:00 python3 -m http.server
root      4570  0.0  0.0   3320  1652 ?        S+   08:38   0:00 grep python

And also in main root
[ec2-user@ip-10-58-182-104 ~]$ ps aux | grep python
root      4560  0.0  0.4  24536 18280 pts/3    S    08:37   0:00 python3 -m http.server
ec2-user  4578  0.0  0.0 119392  1008 pts/2    S+   08:38   0:00 grep --color=auto python

Proc Filesystem https://docs.kernel.org/filesystems/proc.html
The directory /proc contains (among other things) one subdirectory for each process running on the system, which is named after the process ID (PID).
ps uses the proc file system to obtain its information
To get the status information of a process, read the file /proc/PID/status or for the same process (use self link)

$ cat /proc/self/status -- tells status of cat

NAMESPACE
To see all namespaces for proces see
[ec2-user@ip-10-58-182-104 ~]$ sudo ls -lah /proc/$$/ns
total 0
dr-x--x--x 2 ec2-user ec2-user 0 Aug 20 10:05 .
dr-xr-xr-x 9 ec2-user ec2-user 0 Aug 20 10:05 ..
lrwxrwxrwx 1 ec2-user ec2-user 0 Aug 20 10:05 cgroup -> cgroup:[4026531835]
lrwxrwxrwx 1 ec2-user ec2-user 0 Aug 20 10:05 ipc -> ipc:[4026531839]
lrwxrwxrwx 1 ec2-user ec2-user 0 Aug 20 10:05 mnt -> mnt:[4026531840]
lrwxrwxrwx 1 ec2-user ec2-user 0 Aug 20 10:05 net -> net:[4026532089]
lrwxrwxrwx 1 ec2-user ec2-user 0 Aug 20 10:05 pid -> pid:[4026531836]
lrwxrwxrwx 1 ec2-user ec2-user 0 Aug 20 10:05 pid_for_children -> pid:[4026531836]
lrwxrwxrwx 1 ec2-user ec2-user 0 Aug 20 10:05 user -> user:[4026531837]
lrwxrwxrwx 1 ec2-user ec2-user 0 Aug 20 10:05 uts -> uts:[4026531838]




Tips and Tricks
======================
BG
As an aside, if you really want a command to run in background fully do (it will work even after shell has exited)
$ nohup command &>/dev/null &
Note: Ending the command with the ampersand sign does not detach the command from you. It merely sends it to the background of the current shell that you are using, the command will still print the output to STDOUT or STDERR which will prevent you from executing other commands on the terminal.

PSTREE
$ pstree -p (or -sph) -- shows the process tree visual

[ec2-user@ip-10-58-182-104 ~]$ echo $$
5488
Retrun the pid of current process

[ec2-user@ip-10-58-182-104 ~]$ echo $PPID
5488
Retrun the pid of parent process


++++++++++++++++++++++
Resources
Book: How Linux works
chroot: https://www.linuxfoundation.org/blog/blog/a-brief-look-at-the-roots-of-linux-containers
Intro to namespace: https://www.youtube.com/watch?v=-YnMr1lj4Z8
Sysdig : https://www.youtube.com/watch?v=gMpldbcMHuI
https://ericchiang.github.io/post/containers-from-scratch/
https://www.linuxtechi.com/run-linux-shell-command-in-background/

